On mock_calls, mock objects and side effects.

Take this __init__:

    @patch('ordermenu.Order_menu')
    @patch('couriermenu.Courier_menu')
    @patch('productmenu.Product_menu')
    def setUp(self, mock_product: MagicMock, mock_courier: MagicMock,
              mock_order: MagicMock):
        self.testmenu = main.Menu()
        self.mock_product = mock_product
        self.mock_product.reset_mock()
        self.mock_courier = mock_courier
        self.mock_courier.reset_mock()
        self.mock_order = mock_order
        self.mock_order.reset_mock()

The thing we are interested in is the mock_product object, it is called upon
creating a main.Menu() object so I called the reset function afterwards.
We have patched in various menu objects as mocks, these mocks do
nothing, but we can analyse and assert calls made to them, I have assigned them
to self to utilise in a later test.
setUp is a built-in function we can modify for our test cases, this function
will run BEFORE every unit test we run.
We can also modify a similar function, tearDown which runs AFTER every test
case.
Now let's look at a unit test:

    @patch('main.sleep')
    @patch('builtins.print')
    @patch('builtins.input')
    def test_product_menu_create(self, mock_input: MagicMock,
                                 mock_print: MagicMock, mock_sleep: MagicMock,
                                 ):
        mock_input.side_effect = ['1', '0']
        self.testmenu.view_products_menu()
        mock_print.assert_called_with('Exitting products menu...')
        self.assertEqual(self.mock_product.mock_calls[0][0],
                         '().set_product_create')

The method we are testing utilises print and input functions, and we want to
check that the set_product_create function of our mock_product is being called.
Remember to preface print and input patches with builtins.
The actual function being tested is a While True loop, if 0 is input, it exits,
and if 1 is input, it goes to our function, then back to the start of the loop.
First thing of note is how we can use side_effect to 'queue' in multiple input
values: 1, then 0, this means we can test input '1', and then exit the program
without being caught in an infinite loop.
The second thing is what we use to check the calls to our mock_products, it is
an attribute known as mock_calls, you'll notice there are two list indexes:
    The first is a list of how many calls were made, we're looking for the
    first one, so index 0.
    The second is list containing various attributes about the call itself, the
    first index gives us the call name while other indexes give info about
    the arguments being passed in.

Side note: Import MagicMock and use type hinting to pass in your mock arguments
as MagicMock so that VSCode knows to autofill in your mock methods.
